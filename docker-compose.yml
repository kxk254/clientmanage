services:

  # Service for your Python application
  app:
    # Build the image using the Dockerfile in the current directory
    build:
      context: .
      dockerfile: Dockerfile
    # No port mapping here, Nginx will handle external access
    # Mount a volume to share collected static files with Nginx
    container_name: app2
    volumes:
      # This maps the named volume 'static_volume' to a directory
      # inside the app container.
      # IMPORTANT: Configure your application (e.g., STATIC_ROOT in Django)
      # to output collected static files to /remanager/staticfiles
      - static_volume2:/remanager/staticfiles
      - media_volume2:/remanager/media
      - db_volume2:/remanager/db
      - /mnt/nas/develop/re_model/db_backups:/remanager/nas_backups_mount:ro 


    # Override the Dockerfile's CMD to first collect static files
    # and then start the Gunicorn server.
    # This assumes your application uses 'manage.py collectstatic' (like Django).
    # Adjust the command if your framework uses a different method.
    command: /bin/bash -c "cd /remanager && 
              python manage.py collectstatic --noinput && 
              python manage.py migrate --noinput && 
              chown -R 101:101 /remanager/staticfiles /remanager/media && 
              exec gunicorn core.wsgi:application --bind 0.0.0.0:8000"
      # '--noinput' automatically answers yes to prompts (like overwriting files)
      # 'exec' replaces the bash process with gunicorn

    # Ensure Nginx waits for the app container to be healthy (optional but recommended)
    # If you have a healthcheck defined in Dockerfile or here
    # healthcheck:
    #   test: ["CMD", "curl", "-f", "http://localhost:8000/health"] # Example
    #   interval: 30s
    #   timeout: 10s
    #   retries: 3

  # Service for Nginx
  nginx:
    image: nginx:latest
    container_name: nginx2
    # Map host port 8900 to Nginx's default HTTP port 80
    ports:
      - "8700:80"
    # Mount the custom Nginx configuration file
    volumes:
      # Mount your local nginx.conf to the default Nginx server block config
      - ./nginx/nginx2.conf:/etc/nginx/conf.d/default.conf
      # Mount the same shared volume where the app collected static files.
      # This path (/usr/share/nginx/html/static) should match the 'alias'
      # path configured in your nginx.conf for the /static/ location.
      - static_volume2:/usr/share/nginx/html/static
      - media_volume2:/usr/share/nginx/html/media
    # Ensure Nginx starts after the app service
    depends_on:
      - app2

# Define the named volume that will be shared
volumes:
  static_volume2:
  media_volume2:
  db_volume2:

# Optional: Define a custom network (good practice)
# networks:
#   app_network:
#     driver: bridge
#
# If using a custom network, add 'networks: - app_network' to each service

# Component	Primary Stack (app)	Backup Stack (app2)	Conflict?
# Container name	app	app2	❌ No
# Static volume	static_volume	static_volume2	❌ No
# Media volume	media_volume	media_volume2	❌ No
# DB volume	db_volume	db_volume2	❌ No
# Nginx container	nginx	nginx2	❌ No
# Nginx port	8900:80	8700:80	❌ No
# NAS Mount	Both use same path, but :ro	✅ Safe read-only on app2	❌ No